% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/countWorkDays.R, R/date_functions.R
\name{CountWorkDays}
\alias{CountWorkDays}
\alias{date_functions}
\alias{Year}
\alias{Quarter}
\alias{Month}
\alias{Week}
\alias{Day}
\alias{Day<-}
\alias{Weekday}
\alias{YearDay}
\alias{YearWeek}
\alias{YearMonth}
\alias{isWeekend}
\alias{isLeapYear}
\alias{Hour}
\alias{Minute}
\alias{Second}
\alias{Now}
\alias{Today}
\alias{DiffDays360}
\alias{LastDayOfMonth}
\alias{Timezone}
\alias{YearDays}
\alias{MonthDays}
\alias{Month.ym}
\alias{Year.ym}
\alias{Year.default}
\alias{Month.default}
\alias{Zodiac}
\title{Count Work Days Between Two Dates}
\usage{
CountWorkDays(from, to, holiday = NULL, nonworkdays = c("Sat", "Sun"))

Year(x)

\method{Year}{ym}(x)

\method{Year}{default}(x)

Month(
  x,
  fmt = c("m", "mm", "mmm"),
  lang = .getOption("lang"),
  stringsAsFactors = TRUE
)

\method{Month}{ym}(
  x,
  fmt = c("m", "mm", "mmm"),
  lang = .getOption("lang"),
  stringsAsFactors = TRUE
)

\method{Month}{default}(
  x,
  fmt = c("m", "mm", "mmm"),
  lang = .getOption("lang"),
  stringsAsFactors = TRUE
)

Week(x, method = c("iso", "us"))

Day(x)

Day(x) <- value

Weekday(
  x,
  fmt = c("d", "dd", "ddd"),
  lang = .getOption("lang"),
  stringsAsFactors = TRUE
)

Quarter(x)

Today()

Now()

Hour(x)

Minute(x)

Second(x)

Timezone(x)

YearMonth(x)

YearWeek(x, method = c("iso", "us"))

YearDay(x)

DiffDays360(start_d, end_d, method = c("eu", "us"))

LastDayOfMonth(x)

YearDays(x)

MonthDays(x)

Zodiac(x, lang = c("en", "de"), stringsAsFactors = TRUE)

isWeekend(x)

isLeapYear(x)
}
\arguments{
\item{from}{the initial dates}

\item{to}{the final dates}

\item{holiday}{a vector with dates to be excluded.}

\item{nonworkdays}{a character vector containing the abbreviations of the
weekdays (as in \code{day.abb}) to be considered non work days. Default is
\code{c("Sat","Sun")}.}

\item{x}{the date to be evaluated.}

\item{fmt}{format string, defines how the month or the weekday are to be
formatted. Defaults to \code{"m"}, resp. \code{"d"}. Is ignored for other
functions.}

\item{lang}{optional value setting the language for the months and daynames.
Can be either \code{"local"} for current locale or \code{"engl"} for
english. If left to \code{NULL}, the option \code{"lang"} will be searched
for and if not found \code{"local"} will be taken as default.}

\item{stringsAsFactors}{logical. Defines if the result should be coerced to
a factor, using the local definitions as levels.  The result would be an
ordered factor. Default is TRUE.}

\item{method}{one out of \code{"eu", "us"}, setting either European or
US-Method calculation mode. Default is \code{"eu"}.}

\item{value}{new value}

\item{start_d, end_d}{the start, resp. end date for \code{DiffDays360}.}
}
\value{
an integer vector

a vector of the same dimension as x, consisting of either numeric
values or characters depending on the function used.
}
\description{
Returns the number of work days between two dates taking into account the
provided holiday dates.

Some more date functions for making daily life a bit easier. The first ones
extract a specific part of a given date, others check some conditions.
}
\details{
The function is vectorised so that multiple initial and final dates can be
supplied. The dates are recycled, if their number are different.

These functions are mainly convenience wrappers for the painful
\code{format()} and its strange codes...\cr Based on the requested time
component, the output is as follows:\cr \tabular{ll}{ \code{Year}\tab
returns the year of a date or a yearmonth (\code{yyyymm}) in (\code{yyyy})
format .\cr \code{Quarter}\tab returns the quarter of the year (1 to 4) for
the input date. \cr \code{Month}\tab returns the month of the year (1 to 12)
for the input date or for a yearmonth. \cr \code{Week}\tab returns the week
of the year for the input date (0 to 53), as defined in ISO8601. \cr
\code{Weekday}\tab returns the week day of the input date. (1 - Monday, 2 -
Tuesday, ... 7 - Sunday). (Names and abbreviations are either english or in
the current locale!)\cr \code{YearDay}\tab returns the day of the year
numbering (1 to 366). \cr \code{Day}\tab returns the day of the month (1 to
31). \cr \code{YearDay}\tab returns the yearday representation (yyyyddd) of
a date as long integer. \cr \code{YearWeek}\tab returns the yearweek
representation (yyyyww) of a date as long integer. \cr \code{YearMonth}\tab
returns the yearmonth representation (yyyymm) of a date as long integer. \cr
\code{Hour}, \code{Minute}, \code{Second} \tab returns the hour, minute or
second from a POSIXlt object. \cr \code{Timezone} \tab returns the timezone
from a POSIXlt object. \cr \code{HmsToMinute} \tab converts the time parts
of a POSIXlt object to minutes.\cr \code{Today}, \code{Now}\tab returns the
current date, resp. the current date and time.\cr

\code{isWeekend} \tab returns \code{TRUE}, if the date x falls on a weekend.
\cr \code{isLeapYear} \tab returns \code{TRUE}, if the year of the date x is
a leap year. \cr } The day can not only be extracted, but as well be
defined. See examples. \tabular{ll}{ \code{DiffDays360} \tab calculates the
difference between 2 dates using the 360-days convention.\cr
\code{LastDayOfMonth} \tab returns the last day of the month of the given
date(s). \cr \code{YearDays} \tab returns the total number of days of the
given date(s). \cr \code{MonthDays} \tab returns the numer of days of the
month of the given date(s). \cr } The language in \code{Weekday()} and
\code{Month()} can be set with an option as well.  These functions will
check for an existing option named \code{"lang"} and take this value if it
exists. So simply set \code{option(lang="engl")} if the results should
always be reported in English.
}
\examples{

from <- as.Date("2019-01-01") + rep(0, 10)
to <- as.Date("2020-01-15") + seq(0, 9)

CountWorkDays(from, to)

x <- seq(from[1], from[1]+11, "days")
x <- to
data.frame(
  date = x, 
  day  = fm(x, fmt="ddd"))

CountWorkDays(from = min(x), to = max(x), holiday = c("2019-01-06", "2019-01-07"))


x <- Today()    # the same as Sys.Date() but maybe easier to remember..

Year(x)
Quarter(x)

Month(x)
Month(x, fmt = "mm", lang="en")
Month(x, fmt = "mm", lang="local")
Month(x, fmt = "mmm", lang="en")
Month(x, fmt = "mmm", lang="local")

Week(x)

Day(x)
Day(x) <- 20
x

Weekday(x)
Weekday(x, fmt = "dd", lang="en")
Weekday(x, fmt = "dd", lang="local")
Weekday(x, fmt = "ddd", lang="en")
Weekday(x, fmt = "ddd", lang="local")

YearDay(x)

isWeekend(x)

isLeapYear(x)

# let's generate a time sequence by weeks
Month(seq(from=as.Date(Sys.Date()), to=Sys.Date()+150, by="weeks"), fmt="mm")

LastDayOfMonth(as.Date(c("2014-10-12","2013-01-31","2011-12-05")))


}
\seealso{
\code{\link{weekdays}}, \code{Date Functions}

\code{\link{strptime}}, \code{\link{DateTimeClasses}},
\code{\link{as.POSIXlt}}
}
\author{
Andri Signorell \href{mailto:andri@signorell.net}{andri@signorell.net}
}
\keyword{chron}
